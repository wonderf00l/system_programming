
![[../_resources/Pasted image 20241103122558.png]]
- ОС - менеджер аппаратного обеспечения, менеджер железа
- ОС - не только ядро, это все необходимое для работы. Ядро - только часть ОС, которая связывает все части ОС
- Даже компилятор - не часть ОС, ОС достаточно скомпилировать один раз и далее она работает
- Память ядра, код ядра, его процесс - все это пространство именуется kernel space
- У kernel есть права на работу с железом
	- выделение физической памяти
	- запись на диск
	- и тд
- Код может работать в:
	- User mode - наш пользовательский код
	- Kernel mode - исполнение кода ядра
- Например, системный вызов write(), сделанный в user mode, инициирует переключение на kernel mode и исполнение кода ядра
- В микроядрах часть процессов ОС находятся в user space(например, coreaudiod, bluetoothd демоны и тд), эти прцоессы могут рабоать с ядром

![[../_resources/Pasted image 20241103124057.png]]
- Пользовательский код может обращаться к функционалу ядра через syscalls
- То есть вызов происходит в процессе из user space --> прокидывание аргументов через стек процесса и регистра в ядро --> исполнение кода ядра в другом процессе(в процесес ядра)
![[../_resources/Pasted image 20241103130220.png]]
- Аппаратные прерывания
	- Сигнал приходит на процессор(через провод, bluetooth etc)
	- Если на данный момент ядро занято критической работой, прерывания выстраиваются в очередь
	- Вызывается handler прерывания
	- Процессор отличает типы прерываний по номеру, источник прерывания - по пину, на который пришло прерывание(известны заранее) 
- When an interrupt occurs, the CPU stops executing the current running program, switches to kernel mode, executes interrupt handler. This handler saves the state of CPU, performs its operations, restores the state and returns to user mode
![[../_resources/Pasted image 20241103130918.png]]
- Прерывания обрабатываются по очереди одно за одним ***в отдельном стеке(?)***
- Обработка прерывания - создание задачи на обработку в очереди задач в коде ядра, исполнение задач в отдельных воркерах
- Top-bottom half design pattern
	- Top-half - первичная обработка здесь сейчас с требованиями по скорости
	- Bottom-half - основная обработка в менее критическом контексте

![[../_resources/Pasted image 20241103132239.png]]
- Запуск ядра производится Bootloader'ом(загрузчиком) - он ищет исполняемый файл выбранной ОС(или default os) и запускается его
- Загрузчик же вызывается программой BIOS - встроенное ПО, которое запускается при подаче питания(который инициируется нажатием кнопки запуска)
- Это программный код, который подрубает все железо в системе. программа BIOS ищет код bootloader на диске и передает ему управление
- Код программы BIOS сохраняется в read only memory(***ROM*)*** - физическое устройство, куда хардкодится embedded программа(встраивается производителем железа)
- При подаче электрического сигнала программа исполняется 
- ***Каким образом код BIOS попадает из ROM на процессор?***(Исполнять код может только процессор)
	- При подаче стартует в том числе процессор
	- В момент запуска на процессоре отсутствуют инструкции для исполнения
	- Процессор детектит это состояние и выполняет инструкцию ***jump***(аля go-to) пряо на адрес начала программы BIOS в ROM(это адрес известен процессору заранее)

![[../_resources/Pasted image 20241103133827.png]]
- BIOS - работает напрямую с железом, аппаратно зависимый софт, позволяет управлять железками
- подрубает все устройства, подключенные к материнской плате

- Сам BIOS устроен как можно проще, поскольку программа ограничена малым объемом ROM
- Чтобы bios найти загрузчик, нужно предоставить ему понятную ему структуру хранения информации о нахождении программы
- BIOS-совместимые устройства содержат, например, в начале памяти некую структуру с оффсетом от начала памяти устройства, с оффсетом до кода загрузчика
- BIOS стартует загрузчик и заканчивает исполнение

- Загрузчик уже может быть много сложнее, поскольку не ограничен объемом ROM

---
https://slides.com/gerold103/sysprog_eng1


