
- ***Мультиплексирование дескрипторов*** - работа с нескольмими дескрипторами "сразу", то есть не блокируясь на одном из в бесконечном ожидании байт данных из дескриптора
- Обязательно к использованию в рамках треда. Создание нового треда на каждый дескриптор очень расточительно 
- Способы мельтиплексирования
	1. Слияние дескрипторов в один и работа с одним дескриптором
	2. Работа с несколькими дескрипторами

![](../_resources/Pasted%20image%2020250109001458.png)
- Сложность обслуживания дескрипторов таким образом - O(N), N - число дескрипторов
- Причем если дескриптор был обработан, получили ошибку отсутствия данных, а на след итерации они появились, дескриптор будет обработан повторно только через N итераций
- Каждая из итераций - системный вызов на чтение данных из дескриптора, лишние походы в ядро

![](../_resources/Pasted%20image%2020250112160819.png)

#### Select
![](../_resources/Pasted%20image%2020250112160923.png)
- ***Select()*** блокируется в ожидании соответствующего события на одном из дескрипторов
- Не слишком удобный API: max 1024 дескриптора, неявное поведение с timeout, повторное формирование наборов дескрипторов по событиям

Пример: http://github.com/sysprogio/sysprog/blob/master/lecture_examples/9_aio/4_server_select.c

- Общий принцип работы:
	- регистрация наборов дескрипторов на чтение/запись/появление ошибок перед каждым вызовом select
	- ***errorfds*** - сюда добавляем дескрипторы, если нужно оперативно обрабатывать ошибки, связанные с ними
	- получение события или таймаут
	- проверка нужных дескрипторов на наличие события, обработка события


#### Poll
![](../_resources/Pasted%20image%2020250112163105.png)
![](../_resources/Pasted%20image%2020250112163115.png)
- API намного интуитивнее ***select***
- Главный минус - ядро линейно проходит по всем дескрипторам и вешиает на них трекинг события, если его не было при посещении. При детекте события нужно пройтись и снять трекинг с дескрипторов, на которые не прилетели события. При большом числе дескрипторов вызов ***poll*** весьма затратен

#### kqueue(Mac, FreeBSD)

![](../_resources/Pasted%20image%2020250112164930.png)
- Подписка на различные события ядра(не только ***IO***)

```C
int kq = kqueue(); // create the queue

/*
Track a new event on the descriptor fd. Each event (read, write) needs an own kevent
*/
struct kevent new_ev;
EV_SET(&new_ev, fd, EVFILT_READ/WRITE/..., EV_ADD, 0, 0, 0); // добавить в очередь прослушку событий чтения/записи дескриптора fd 
kevent(kq, &new_ev, 1, 0, 0, NULL);

// fetch happened events
struct kevent happened_ev;
kevent(kq, NULL, 0, &happened_ev, 1, NULL); // получение случившихся событий
if (happened_ev.filter | EVFILT_READ)
        /* Can safely read from happened_ev.ident. */
if (happened_ev.filter | EVFILT_WRITE)
        /* Can safely write to happened_ev.ident. */

// Delete an event from tracking
struct kevent old_ev;
EV_SET(&old_ev, fd, EVFILT_READ/WRITE/..., EV_DELETE, 0, 0, 0);
kevent(kq, &old_ev, 1, 0, 0, NULL);
```
![](../_resources/Pasted%20image%2020250112165118.png)

#### epoll
![](../_resources/Pasted%20image%2020250112171004.png)


#### IO batching
![](../_resources/Pasted%20image%2020250112171736.png)
- Можно записать N байт-буферов в файл/сокет за 1 syscall, вместо N syscalls на N буферов
- для сокетов - функции `recvmmsg()/sendmmsg()`
- линейный рост производительности