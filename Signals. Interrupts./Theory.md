
![](../_resources/Pasted%20image%2020241201230933.png)
![](../_resources/Pasted%20image%2020241201230945.png)
- Аппаратные прерывания - некоторые сигналы от периферии, которые обрабатываются процесором
- Программные - для обработки ситуаций, происходящих на самом процессоре, а не на периферии, генерируются и обрабатываются процессором, но причина их появления - пользовательский код
	- zero division
	- дебаг - breakpoint - это инструкция, генерирующая прерывание в точке останова, обработка которого приводит к остановке на этой точке
	- page fault - при TLB miss, write to COW memory segment etc


![](../_resources/Pasted%20image%2020241201231521.png)
Flow чтения с диска:
- В коде делается read syscall
- Через спец инструкцию syscall попадаем сразу в ядро
- Идем в файловую систему в ядре, находим нужный файл и соответствующее ему устройство
- Посылаем в драйвер устройства команду для исполнения, байты данных
- Это команда/данные ставятся на шину данных
- Все устройства ее видят, но по шине она доходит до диска, исполняется



> Главная проблема - все периферийные устройства много медленнее процессора. Поэтому нужен механизм, который позволит процессору отправить команду устройствам асинхронно и пойти дальше выполнять инструкции. А когда устройство завершит работу, то даст об этом знать 

![](../_resources/Pasted%20image%2020241201232756.png)
![](../_resources/Pasted%20image%2020241201232823.png)
![](../_resources/Pasted%20image%2020241201232829.png)
![](../_resources/Pasted%20image%2020241201232843.png)![](../_resources/Pasted%20image%2020241201232853.png)
- Если устройствам есть что сказать cpu, то они генерируют прерывание
- Прерывание отправляется не непосредственно на cpu, а в PIC, где они копятся в порядке очереди.
- У PIC есть регистр, в который пишется номер устройства, идентифицирующий прерывание
- У процессора есть элемент, сигнализирующий о готовности обработать прерывание
- PIC это видит и посылает по шине прерывание
- Процессор его получает, считывает через шину номер устройства, обрабатывает прерывание
- И так в порядке очереди, значение устройства в регистре PIC поочередно меняется


![](../_resources/Pasted%20image%2020241201233421.png)
- Программные же прерывания возникают на самом процессоре, обычно это разные ошибки
- Выглядит это так, что процессору встречается инструкция, которую нельзя выполнить. Тут генерится прерывание и вызывается обработчик в ядре. Итогом обработки станет либо последующая обработка, либо exit с кодом ошибки

![](../_resources/Pasted%20image%2020241201234242.png)
- Errors(exceptions) - прерывания - ошибки(не всегда критичные)
	- для таких прерываний вызовется обработчик
	- после работы хендлера попытаемся заретраить ***инструкцию, вызвавшую прерывание*** - будем ретраиться, пока инструкция не выполниться, либо пока хендлер не завершит исполнение инструкций принудительно
	- ретрай пройдет, например, если при выполнении инструкции получили page fault, или запись в cow сегмент --> хендлер прерывания загрузит мапинг в TLB/выделит память в пространстве дочернего процесса --> при ретрае корректно исполним инструкцию 
- Traps - после обработки прерываний, вызванных инструкцией, перейдем сразу к следующей инструкции, без ретрая
	- Системные вызовы - незачем ретраить

