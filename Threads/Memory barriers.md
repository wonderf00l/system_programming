
Барьеры памяти (memory barriers) необходимы для обеспечения правильного порядка выполнения команд процессором и предотвращения нежелательного переупорядочивания инструкций, которое может привести к непредсказуемому поведению программы, особенно в многопоточной среде.

### Что вызывает переупорядочивание инструкций?
Переупорядочивание инструкций может происходить как на этапе компиляции, так и на этапе исполнения программы процессором.

1. **Компилятор:** Компиляторы оптимизируют код, изменяя порядок выполнения инструкций для повышения эффективности. Например, компилятор может переставлять инструкции, если видит, что это не повлияет на логику программы в однопоточном исполнении.

2. **Процессор:** Процессоры также выполняют оптимизации на аппаратном уровне. Например, современные процессоры имеют конвейеры команд, кэш-память и внеочередное выполнение инструкций (out-of-order execution), что позволяет им выполнять команды в порядке, отличающемся от исходного, для ускорения работы.

### Почему важно предотвращать переупорядочивание?
В многопоточной программе порядок выполнения инструкций критичен для корректной синхронизации данных между потоками. Рассмотрим следующий пример:

```cpp
// Поток 1
x = 1;
flag = true;

// Поток 2
while (!flag) {}
print(x); // Ожидается вывод '1'
```

Без барьеров памяти процессор или компилятор могут изменить порядок выполнения инструкций в первом потоке, так что сначала установится `flag`, а потом `x`. В результате второй поток может прочитать `x` до того, как оно было установлено равным `1`, и вывести неожиданное значение.

### Зачем нужны барьеры памяти?
Барьеры памяти гарантируют, что определенные инструкции выполняются строго в указанном порядке и что данные правильно синхронизируются между потоками. Они делятся на три основных типа:

1. **Write Barrier (Запись):** Гарантирует, что все записи в память перед барьером завершатся до любых последующих операций.
2. **Read Barrier (Чтение):** Гарантирует, что все последующие чтения из памяти произойдут после всех предыдущих операций.
3. **Full Barrier (Полный):** Обеспечивает оба вышеуказанных условия одновременно.

Примером использования барьера памяти может служить инструкция `mfence` в архитектуре x86, которая обеспечивает полный барьер памяти.



![](../_resources/Pasted%20image%2020250103125746.png)

![](../_resources/Pasted%20image%2020250103130012.png)

- Барьеры памяти фиксируют порядок инструкций относительно друг друга
- Барьеры памяти - это конкретные инструкции на языке ассемблера, предотвращающие переупорядочивание инструкций

![](../_resources/Pasted%20image%2020250103125813.png)
- Все инструкции(запись/чтение, что угодно), идущие после инструкции с acquire барьером, будут выполнены строго после, они не могут быть переупорядочены так, что в итоге выполнятся до acquire барьера. Не накладывается ограничение на инструкции, идущие до acquire барьера, то есть они могут быть переупорядочены и в итоге быть выполнены после барьера, хотя в коде идут до. Ключевое - ***инструкции, идущие после барьера, будут выполнены строго после***

![](../_resources/Pasted%20image%2020250103125806.png)
- Наоборот - ***все инструкции, идущие до барьера, выполняются строго до инструкции с барьером.*** Возможно "запрыгивание" последующих инструкции перед барьером.
- Acquire-release барьеры используются в реализации mutex.
	- Например, если бы не было acquire/release барьера, условная инструкция чтения из "thread-safe" мапы могла бы быть выполнена до взятия лока/после релиза лока --> был бы возможен data race

![](../_resources/Pasted%20image%2020250103130025.png)


![](../_resources/Pasted%20image%2020250103131245.png)
- Полный барьер запрещает "перепрыгивание" инструкций через него, то есть они вообще не могут быть переупорядочены относительно него

> Реализация atomic в go включает full barriers




![](../_resources/Pasted%20image%2020250103131415.png)
- Memorder - виды барьеров:
	1. release/acquire
	2. acq_rel - full
	3. relaxed - отсутствие барьера --> полезно, если, например, просто нужно атомарно инкрементировать счетчик