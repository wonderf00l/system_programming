#### Проблема портируемости низкоуровненвых инструментов
![](../_resources/Pasted%20image%2020250103133310.png)
- Примитивы для выполнения атомарных операций, клонирования task structs, работы с futex и проч являются os- и compiler- specific --> стоит использовать кроссплатформенные инструменты для работы с многопоточностью, типа std::thread в C++, threading в python, pthread в C
	- указанные библиотеки работают с нативными системными потоками, то есть под капотом они используют примитивы для клонирования системных task struct и им подобных сущностей, в общем, взаимодействуют с ОС через системные вызовы
	- в случае go горутин используются не нативные потоки ОС, а т.н. легковесные потоки(виртуальные потоки, файберы, green threads etc) - так же происходят обращения к ОС для создания системных потоков, однако выделяются они в меньшем кол-ве и в соответствии с логикой планировщика языка, вся основная работа по организации многопоточности производится в userspace на основе userspace единиц исполнения
	- и в случае go api для работы с этой обвязкой поверх системных тредов - часть языка, буквально его ключевые слова
	- в других языках также существуют библиотеки, предоставляющие api для работы с подобными "легковесными потоками", типа green threads в java
	- но все это - абстракция над нативными потоками ОС

![](../_resources/Pasted%20image%2020250103132822.png)
- ***pthread***(posix thread) - библиотека для работы с системными потоками на языке C(для unix-подобных систем)

##### Работа с потоками
![](../_resources/Pasted%20image%2020250103162042.png)
- Ключевые концепты:
	- Каждый поток работает на своем стеке, который выделяется на куче адресного пространства процесса(главного потока процесса)
	- Передаваемая функция треда исполняется на отдельном стеке, после завершения функции он добавляется в список стеков на удаление(по факут списов адресов на удаление, удаление производится после выставления оп. системой tid в 0 - знак завершения работы cloned таска)
	- Очередной склонированный тред подчищает стек исполнившегося треда, либо как-то переиспользует его
	- thread_join - активное ожидание финиша треда вида
	```go
	for !thread.is_finished {}
	// do thread termination ops
	```
	- thread_detach - открепление потока, detached потоки не обязательно дожидаться с join

##### Mutex
![](../_resources/Pasted%20image%2020250103162532.png)
- Инициализация и удаление мьютекса
- mutex lock/unlock - 