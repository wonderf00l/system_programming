
- Есть потребность в разбиении разных задач, напрямую не зависящих друг от друга, в распределении их на разные физические ядра и распараллеливании, либо в организации конкурентного выполнения

![](../_resources/Pasted%20image%2020250101210458.png) 
##### Решение 1 - исполнять такие задачи в разных однопоточных процессах
- Большая часть проблем связана с тем, что у ***процессов разные ресурсы*** - память, дескрипторы и проч --> из-за этого усложняется коммуникация между процессами, в принципе сложнее организовать работу разных процессов над одним ресурсом, потому что ***каждый процесс оперирует своим экземпляром ресурса***
- Поэтому появляются проблемы сериализации/десериализации данных сообщений для процессов(IPC), лишнего копирования данных и проч


![](../_resources/Pasted%20image%2020250101211104.png)

##### Решение 2 - исполнять такие задачи в рамках 1-ого многопоточного процесса
- Концепция потоков - единиц исполнения, разделяющих общие ресуры, такие как дескрипторы, память и проч., - устраняет проблемы первого подхода: мы бувально работаем с одной и той же памятью, с одними и теми же виртуальными адресами, которые неинвалидируются при передачи из 1-ого процесса в другой, напрямую вызываем функции, расположенные по общим адресам и проч


![](../_resources/Pasted%20image%2020250101211422.png)


![](../_resources/Pasted%20image%2020250101214419.png)
- Syscall для клонирования task struct - для создания потока нужно склонировать таблицу fd, директорию, pid, виртуальную память.
- thread id будут разными

![](../_resources/Pasted%20image%2020250101214336.png)
- Клонированный такс исполняется на своем стеке. Он заранее выделяется(на куче) и чистится после работы cloned таска(треда)



##### Volatile - отключение оптимизаций компилятора
Пример - https://slides.com/gerold103/sysprog_eng6#/12/0/5


##### Атомарность операций

![](../_resources/Pasted%20image%2020250101230157.png)
![](../_resources/Pasted%20image%2020250101230227.png)
- Проблема неатомарного инкремента - фактически инкремент это 3 операции, т.к. процессор умеет только загрузить в регистр(load), изменить значение в регистре, выгрузить значение из регистра в память(store)


![](../_resources/Pasted%20image%2020250101230457.png)
- Atomic API - инструменты для выполнения атомарных операций - такие функции будут компилироваться как неделимые атомарные ассемблерные инструкции 

> Атомарные операции - это userspace only операции, никаких syscalls не делается

![](../_resources/Pasted%20image%2020250101230628.png)
- Spin lock: атомарное CAS(лок перменной-флажка) - выполнение операций - cas(unlock флажка)


![](../_resources/Pasted%20image%2020250101230736.png)
- Проблема spin lock - это активное ожидание: вместо того чтобы отправить потоки спать, перепланировать их и тп, производится активная работа вхолостую


- ***Mutex*** на основе ***futex*** syscall: https://slides.com/gerold103/sysprog_eng6#/23/0/3



##### Переупорядочивание инструкций процессором, компилятором для ускорения работы

![](../_resources/Pasted%20image%2020250102120023.png)
- Проблема: процессор может выполнить инструкции, не связанные друг с другом логической последовательносстью, по данным и т.п., в произвольном порядке
- Пример: read a может пойти за данными по адресу, отсутствующему в CPU cache --> исполнение инструкции предпалагает поход в озу, в то время как write b обратиться к адресу, уже загруженному в кеш -->  это инструкция исполнится раньше read a

- Разные архитектуры процессора допускают разные упрорядочивания, ***x86_64*** наиболее строгая по числу возможных упорядочиваний






##### Барьеры памяти

Барьеры памяти (memory barriers) необходимы для обеспечения правильного порядка выполнения команд процессором и предотвращения нежелательного переупорядочивания инструкций, которое может привести к непредсказуемому поведению программы, особенно в многопоточной среде.

### Что вызывает переупорядочивание инструкций?
Переупорядочивание инструкций может происходить как на этапе компиляции, так и на этапе исполнения программы процессором.

1. **Компилятор:** Компиляторы оптимизируют код, изменяя порядок выполнения инструкций для повышения эффективности. Например, компилятор может переставлять инструкции, если видит, что это не повлияет на логику программы в однопоточном исполнении.

2. **Процессор:** Процессоры также выполняют оптимизации на аппаратном уровне. Например, современные процессоры имеют конвейеры команд, кэш-память и внеочередное выполнение инструкций (out-of-order execution), что позволяет им выполнять команды в порядке, отличающемся от исходного, для ускорения работы.

### Почему важно предотвращать переупорядочивание?
В многопоточной программе порядок выполнения инструкций критичен для корректной синхронизации данных между потоками. Рассмотрим следующий пример:

```cpp
// Поток 1
x = 1;
flag = true;

// Поток 2
while (!flag) {}
print(x); // Ожидается вывод '1'
```

Без барьеров памяти процессор или компилятор могут изменить порядок выполнения инструкций в первом потоке, так что сначала установится `flag`, а потом `x`. В результате второй поток может прочитать `x` до того, как оно было установлено равным `1`, и вывести неожиданное значение.

### Зачем нужны барьеры памяти?
Барьеры памяти гарантируют, что определенные инструкции выполняются строго в указанном порядке и что данные правильно синхронизируются между потоками. Они делятся на три основных типа:

1. **Write Barrier (Запись):** Гарантирует, что все записи в память перед барьером завершатся до любых последующих операций.
2. **Read Barrier (Чтение):** Гарантирует, что все последующие чтения из памяти произойдут после всех предыдущих операций.
3. **Full Barrier (Полный):** Обеспечивает оба вышеуказанных условия одновременно.

Примером использования барьера памяти может служить инструкция `mfence` в архитектуре x86, которая обеспечивает полный барьер памяти.

### Заключение
Барьеры памяти важны для предотвращения неправильного поведения многопоточных программ, вызванного переупорядочиванием инструкций. Они помогают гарантировать правильную синхронизацию данных между потоками и поддерживают предсказуемость выполнения программы.







