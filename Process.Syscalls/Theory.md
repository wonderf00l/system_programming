![](../_resources/Pasted%20image%2020241114214941.png)
- Процесс - это ***работающая*** программа

![](../_resources/Pasted%20image%2020241114215026.png)
- .text - машинный код программы, который исполняет процессор
- .data - глобальный переменные
- .stack - то на чем работает главный поток процесса
- у каждого потока - свой стек


![](../_resources/Pasted%20image%2020241114215516.png)
- в коде ядра процесс представлен только своим pid
- остальное - таски(треды
- разные потоки одного процесса будут иметь общий указатель на *mm_struct*

#### process pipeline
![](../_resources/Pasted%20image%2020241114220442.png)
- создание дочернего процесса(копия родителя)
- запуск нового исполняемого файла через одну из функций(опционально)
- завершение работы процесса, возврат кода вызова
- ожидание изменения стейта процесса родителем - https://man7.org/linux/man-pages/man2/wait.2.html

![](../_resources/Pasted%20image%2020241114223119.png)
- Все процессы порождаются неким родителем
- Исходным родителем всех процессов является процесс с pid 1
- Он явно инициализируется в коде ядра, стартует со стартом ядра, то есть это заглушка, чтобы у всех процессов был хоть какой-то parent pid
- Тем самым приходим к дереву процессов
- Информацию о parent pid можно получить через системный вызов***ppid()***

![](../_resources/Pasted%20image%2020241114224742.png)


![](../_resources/Pasted%20image%2020241114225737.png)
- ***fork()*** работает быстро даже при порождении ребенка от жирного процесса(какой-то огромный исполняемый файл)
- это потому что копирования не происходит: системный вызов ***fork()*** помечает страницы памяти родительского процесса флажком ***COW*** - ***copy on write***(проставляется аппаратный флажок)
- копирование ***целой страницы***(минимальная единица копирования) будет происходить только при записи дочерним процессом новых данных в адреса это страницы
	- ОЗУ трекает запись и генерирует прерывание для процессора, код ядра обрабатывает прерывание  и дергает сишную функцию для копирования памяти
- при этом например глобальные константы из .data сегменты останутся общие у процессов, чтобы не дублировать память



![](../_resources/Pasted%20image%2020241114231559.png)
- ***vfork() + exec()***
	- ***vfork()*** - то же что и fork, только не помечает страницы памяти флагом COW, то есть в этом случае память вообще не будет копироваться, по факту процессы шарят одну память(unsafe, если далее по коду не вызывается ***exec()*)
	- нужен в связке exec(), чтобы сразу исполнить некий другой код, в этом случае child process работает с абсолютно новой памятью


![](../_resources/Pasted%20image%2020241114231857.png)
- ***wait()*** - ожидает завершения дочернего процесса ***при этом удаляет его из памяти, освобождает pid***
- процессы, которых не дожидаются, - ***zombie-процессы***
	- помечаются спец символом
	- если родитель завершился, то сиротские процессы переходят к *init task struct*, он их собирает и удаляет


![](../_resources/Pasted%20image%2020241114232858.png)
- ***main*** - не точка входа в программу, фактическая точка входа - некая инструкция(может быть и машинная), то есть это не функция - скорее метка о начале исполнения --> ***отсюда становится понятно, почему программа ВСЕГДА должна завершаться инструкцией exit*** - 