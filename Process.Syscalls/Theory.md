![](../_resources/Pasted%20image%2020241114214941.png)
- Процесс - это ***работающая*** программа

![](../_resources/Pasted%20image%2020241114215026.png)
- .text - машинный код программы, который исполняет процессор
- .data - глобальный переменные
- .stack - то на чем работает главный поток процесса
- у каждого потока - свой стек


![](../_resources/Pasted%20image%2020241114215516.png)
- в коде ядра процесс представлен только своим pid
- остальное - таски(треды)
- разные потоки одного процесса будут иметь общий указатель на *mm_struct*

#### process pipeline
![](../_resources/Pasted%20image%2020241114220442.png)
- создание дочернего процесса(копия родителя)
- запуск нового исполняемого файла через одну из функций(опционально)
- завершение работы процесса, возврат кода вызова
- ожидание изменения стейта процесса родителем - https://man7.org/linux/man-pages/man2/wait.2.html

![](../_resources/Pasted%20image%2020241114223119.png)
- Все процессы порождаются неким родителем
- Исходным родителем всех процессов является процесс с pid 1
- Он явно инициализируется в коде ядра, стартует со стартом ядра, то есть это заглушка, чтобы у всех процессов был хоть какой-то parent pid
- Тем самым приходим к дереву процессов
- Информацию о parent pid можно получить через системный вызов***ppid()***

![](../_resources/Pasted%20image%2020241114224742.png)


![](../_resources/Pasted%20image%2020241114225737.png)
- ***fork()*** работает быстро даже при порождении ребенка от жирного процесса(какой-то огромный исполняемый файл)
- это потому что копирования не происходит: системный вызов ***fork()*** помечает страницы памяти родительского процесса флажком ***COW*** - ***copy on write***(проставляется аппаратный флажок)
- копирование ***целой страницы***(минимальная единица копирования) будет происходить только при записи дочерним процессом новых данных в адреса это страницы
	- ОЗУ трекает запись и генерирует прерывание для процессора, код ядра обрабатывает прерывание  и дергает сишную функцию для копирования памяти
- при этом например глобальные константы из .data сегменты останутся общие у процессов, чтобы не дублировать память



![](../_resources/Pasted%20image%2020241114231559.png)
- ***vfork() + exec()***
	- ***vfork()*** - то же что и fork, только не помечает страницы памяти флагом COW, то есть в этом случае память вообще не будет копироваться, по факту процессы шарят одну память(unsafe, если далее по коду не вызывается ***exec()*)
	- нужен в связке с exec(), чтобы сразу исполнить некий другой код, в этом случае child process работает с абсолютно новой памятью


![](../_resources/Pasted%20image%2020241114231857.png)
- ***wait()*** - ожидает завершения дочернего процесса ***при этом удаляет его из памяти, освобождает pid***
- процессы, которых не дожидаются, - ***zombie-процессы***
	- помечаются спец символом
	- если родитель завершился, то сиротские процессы переходят к *init task struct*, он их собирает и удаляет


![](../_resources/Pasted%20image%2020241114232858.png)
- ***main*** - не точка входа в программу, фактическая точка входа - некая инструкция(может быть и машинная)
- то есть это не функция - скорее метка о начале исполнения --> ***отсюда становится понятно, почему программа ВСЕГДА должна завершаться инструкцией exit***
- если убрать вызов exit(), процессор пойдет исполнять инструкции, которые лежат дальше в памяти после кода программы - а там может быть что угодно

![](../_resources/Pasted%20image%2020241115000230.png)
- У каждого процесса свое виртуальное пространство адресов - 2^(64-1) адресов(для x64)
	- Исторически - раньше было всего 2^(32-1) адресов, на кучу процессов
	- Такая виртуализация удобнее и не привязываемся на конкретные физические адреса ОЗУ
- Существуют сегменты адресного пространства - у них конкретное название и назначение, **однако в памяти они могут быть расположены хаотично**, но присутствуют всегда


##### .data/.bss
![](../_resources/Pasted%20image%2020241116171756.png)
- Значения переменных блока .data хранятся на диске, сразу подставляются при загрузке executable в память
- На диске хранится только информация о размере переменных из блока .bss, при загрузке файла в память они инициализируются нулями

![](../_resources/Pasted%20image%2020241116172148.png)
- Разбиение больших кусков памяти на кусочки меньше-меньше-меньше...
- Организация их в какую-то структуру данных(бинарная куча, дерево etc)
- Блоки памяти резервируются(***malloc**), извлекаются из структуры данных, освобождаются и кладутся обратно через спец операторы ***free***

>Что стек, что куча - все есть оперативная память, различается механизм ее выделения и освобождения


![](../_resources/Pasted%20image%2020241117173125.png)
![](../_resources/Pasted%20image%2020241117173356.png)
- ***mmap*** и ***brk*** syscalls - нужны для продвижения ***program break***(границы, до которой адреса остаются валидными для обращения в программе), то есть для расширения диапазона задействованных адресов адресного пространства - иначе говоря, для выделения новой памяти
	- реализации кучи используют mmap для выделения памяти - ***под капотом malloc, new(не являются системными вызовами) etc используют системный вызов mmap***
	- запрос физической памяти и ее мапинг на виртуальную в адресном пространстве процесса
	- мапинг(отображение) содержимого файлов в адресное пространство процесса - то есть загрузка текста файла в памяти процесса
- 