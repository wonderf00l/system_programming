![](../_resources/Pasted%20image%2020241123010301.png)
- ***shared memory*** - память разделяется обоими процессами, не копируется
- выделенная через malloc - анонимная память, copy on write



![](../_resources/Pasted%20image%2020241123013736.png)
- в Userspace файлы представлены числами - файловыми дескрипторами - это числа-индексы в таблице файловых дескрипторов в task struct ядра
- в kernel space файловый дескриптор -  структура file
- ***основной(самый первый) и дочерние task structs процесса будут иметь общий указатель на таблицу файловых дескрипторов***

![](../_resources/Pasted%20image%2020241123140659.png)
- стандартные predefined дескрипторы любого процесса - stdin, stdout, stderr


#### Взаимодействие процессов через файлы - плохая идея(сложно синхронизировать чтение/запись(если не просто append в конец))
![](../_resources/Pasted%20image%2020241123135019.png)
![](../_resources/Pasted%20image%2020241123135214.png)


![](../_resources/Pasted%20image%2020241123135342.png)
- ***dup*** syscall - создает новый файловый дескриптор в userspace
	- это - другое число, которое резервируется ядром
	- это другое число - новый индекс в таблице файловых дескрипторов процесса(task_struct'а) --> то есть ***при дуплицировании должен создаваться новый entry в этой таблице - по смещению равному <адрес начала массива указателей на структуру file ядра> + <новое значение дескриптора(просто число - в userspace)> - этот entry(ячейка массива) будет содержать адрес на ту же структуру file ядра(представление файла - файловый дескриптор в kernel space)***  
	- поэтому все манипуляции с файлом будут shared между этими дескрипторами - ***по сути это алиас на тот же файл***


![](../_resources/Pasted%20image%2020241123141030.png)
- ***после fork() все дескрипторы родителя дублируются в ребенке - как будто на все дескрипторы позвали dup***
- в данном примере всего будет создано 4 указателя, хранящих один и тот же адрес той де структуры файл
- ***файловый дескриптор не закрыт до тех пор, пока на него есть хоть одна живая незакрытая ссылка***


#### Process pipes
![](../_resources/Pasted%20image%2020241123145943.png)
- Концептуально - два файла: в один можем только писать как клиенты пайпа(конец пайпа для записи), из другого - только читать
	- под капотом файлы связываются и данные передаются от файла к файлу 

![](../_resources/Pasted%20image%2020241123141410.png)


![](../_resources/Pasted%20image%2020241123145124.png)
- Пример с созданием пайпа и разветвлением записи
	- через dup2 делаем stdin алиасом на файловый дескриптор для чтения из пайпа(то есть по сути кладем в 0-ую ячейку таблицы файловых дескрипторов указатель на файл, откуда мы как клиенты пайпа можем только читать, туда будут приходить данные, которые будут записаны в файл для записи(конец пайпа для записи), значение указателя на старый файл stdin перетирается, старый дескриптор закрывается)
	- тем самым записывая в to_child[1] также пишем в stdin
