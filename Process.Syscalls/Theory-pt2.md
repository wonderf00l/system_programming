![](../_resources/Pasted%20image%2020241123010301.png)
- ***shared memory*** - память разделяется обоими процессами, не копируется
- выделенная через malloc - анонимная память, copy on write



![](../_resources/Pasted%20image%2020241123013736.png)
- в Userspace файлы представлены числами - файловыми дескрипторами - это числа-индексы в таблице файловых дескрипторов в task struct ядра
- в kernel space файловый дескриптор -  структура file
- ***основной(самый первый) и дочерние task structs процесса будут иметь общий указатель на таблицу файловых дескрипторов***

![](../_resources/Pasted%20image%2020241123140659.png)
- стандартные predefined дескрипторы любого процесса - stdin, stdout, stderr


#### Взаимодействие процессов через файлы - плохая идея(сложно синхронизировать чтение/запись(если не просто append в конец))
![](../_resources/Pasted%20image%2020241123135019.png)
![](../_resources/Pasted%20image%2020241123135214.png)


![](../_resources/Pasted%20image%2020241123135342.png)
- ***dup*** syscall - создает новый файловый дескриптор в userspace
	- это - другое число, которое резервируется ядром
	- это другое число - новый индекс в таблице файловых дескрипторов процесса(task_struct'а) --> то есть ***при дуплицировании должен создаваться новый entry в этой таблице - по смещению равному <адрес начала массива указателей на структуру file ядра> + <новое значение дескриптора(просто число - в userspace)> - этот entry(ячейка массива) будет содержать адрес на ту же структуру file ядра(представление файла - файловый дескриптор в kernel space)***
	- проще говоря, в блоке памяти с последовательно расположенными адресами структур file появляется новое вхождение(с индексом == значение нового userspace fd), новый адреc. В этом вхождении будет лежать адрес на уже существующую ***struct file***. 
	- поэтому все манипуляции с файлом будут shared между этими дескрипторами - ***по сути это алиас на тот же файл***
	- Кейс с перенаправлением потока вывода одного процесса в stdin другого - это не что иное как:
		- инициализация пайпа
		- запись в ячейку таблицы файловых дескрипторов с номером STDOUT указателя на struct file для записи(конец пайпа для записи) - через ***dup2***
		- аналогичное переиспользование ячейки таблицы с номером STDIN другого процесса - запись в эту ячейку указателя на struct file для чтения


![](../_resources/Pasted%20image%2020241123141030.png)
- ***после fork() все дескрипторы родителя дублируются в ребенке - как будто на все дескрипторы позвали dup***
- в данном примере всего будет создано 4 указателя, хранящих один и тот же адрес той де структуры файл
- ***файловый дескриптор не закрыт до тех пор, пока на него есть хоть одна живая незакрытая ссылка***


#### Process pipes
![](../_resources/Pasted%20image%2020241123145943.png)
- Концептуально - два файла: в один можем только писать как клиенты пайпа(конец пайпа для записи), из другого - только читать
	- под капотом файлы связываются и данные передаются от файла к файлу 

![](../_resources/Pasted%20image%2020241123141410.png)


![](../_resources/Pasted%20image%2020241123145124.png)
- Пример с созданием пайпа и разветвлением записи
	- через dup2 делаем stdin алиасом на файловый дескриптор для чтения из пайпа(то есть по сути кладем в 0-ую ячейку таблицы файловых дескрипторов указатель на файл, откуда мы как клиенты пайпа можем только читать, туда будут приходить данные, которые будут записаны в файл для записи(конец пайпа для записи), значение указателя на старый файл stdin перетирается, старый дескриптор закрывается)
	- тем самым записывая в to_child[1] также пишем в stdin

#### Syscalls
![](../_resources/Pasted%20image%2020241123165439.png)
- Системные вызовы не стандартизованы от ОС к ОС, стандартизовано лишь поведение, ожидаемое от ОС, то есть в стандартах описано только общее системное api
- Однако сами сигнатуры и функции могут быть реализованы по-разному

***Пример:***
1. В unix-like процесс порождается функцией ***fork()*** стандартной библиотеки С, которая под капотом дернет sys_fork(), это уже конкретная инструкция вида syscall instruction + syscall num as an arg
2. ***! sys_fork() - linux-специфичный syscall, например, windows предоставляет иной api для примерно того же самого - CreateChildProcess()***. Для windows принцип тот же: будут некие обертки над сырым windows syscall, которые будут дергать windows specific syscall типа CreateChildProcess() и др. Сами обертки уже будут находиться в других стандартных библиотеках для винды
3. То есть исполнение бинаря, который дергает какие-нибудь ***fork(), pipe() или mmap()*** на винде приведет к крашу, оно не исполнится

![](../_resources/Pasted%20image%2020241123165412.png)
- Таблица вида номер сискола - хендлер в коде ядра Linux
- Есть not implemented заглушки - чтобы дремучие executables явно получали ошибки при вызове syscalls, которые уже deprecated на новых версиях ОС


#### Как сделать системный вызов?
![](../_resources/Pasted%20image%2020241123171558.png)
- в любом случае syscall - это инструкция, которая исполняется процессором. эта инструкция позволяет попасть в контекст kernel space и исполнить инструкции кода ядра
- вопрос в том, что именно за инструкция и как она обрабатывается
1. Старый способ
	- генерировать специальное прерывание(инструкция int(interrupt) 128(номер прерывания)) - спец прерывание, зарезерированное под системные вызовы
	- аргументы syscall передаются через регистры, стек
	- при исполнении инструкции interrupt процессор идет в табличку прерываний(***идет в ОЗУ - главная причина того, почему это очень дорого***), по номеру прерывания находит адрес инструкции(то есть функции-хендлера) в ядре, которую на это прерывание нужно исполнить для его обработки
	- исполняется инструкция ***jump*** на найденный адрес инструкции в kernel space
	- теперь мы в контексте ядра, тут уже понимаем, что нужно обработать syscall - аргументы syscall берем из регистра, стека процесса из userspace
2. Современный подход
	- Процессоры научились обрабатывать новую спец инструкцию для syscalls - ***syscall*** - в этом случае сразу переключаемся в контекст ядра, аргументы передаются так же через регистры, стек
	- В этом случае сильно экономим за счет того, что не ходим в ОЗУ для определения типа прерывания
![](../_resources/Pasted%20image%2020241123172452.png)






![](../_resources/Pasted%20image%2020241123173041.png)
- Virtual Dynamic Shared Object - во всех процессах есть сегмент виртуальной памяти, который ссылается на открытые сегменты памяти ядра(например, счетчик времени)
- То есть условный time.Now не делает syscall, а идет в эту область памяти процесса
- Все такие области памяти процессов ссылаются на область виртуальной памяти адресного пространства ядра, оно уже мапится на физическую память 

#### Summary
##### Процесс - абстракция ОС, олицетворяющая работающую программу и ее ресурсы
##### Процесс коммуницирует с внешним миром(локальные хранилища, сеть, другое железо, другие процессы) через ядро. В ядро из процесса попадаем через системные вызовы - вызовы функций-обработчиков в коде ядра
![](../_resources/Pasted%20image%2020241123173603.png)