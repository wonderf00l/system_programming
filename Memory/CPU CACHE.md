![](../_resources/Pasted%20image%2020241130005157.png)

![](../_resources/Pasted%20image%2020241130005222.png)
1. Размер кеша процессора кратен степени двойки, чтобы его можно было максимально заполнить
2. В кеше хранятся метаданные не по каждому байту памяти, это было бы крайне невыгодно, а по блокам памяти(кеш строки-кеш линии-64 байта)
3. Кеш состоит из n-ого кол-ва кеш-линий
	- Кеш-линия - это непосредственно сами данные из ОЗУ + некоторая метадата, позволяющая правильно соотнести данные из ОЗУ и данные в кеше
	- Метадата(еще называется тегом) - ***n старших битов адреса ОЗУ,(или номер -ого байта текущей кеш-линии?)*** которые используются при обходе кеш линий(как они обходятся и в каком количестве - зависит от типа устройства кеша), чтобы удостовериться, действительно та ли строка находится в кеше  
4. ОЗУ делится на страницы(4 Кб), которые в свою очередь делятся на сегменты по 64Б(размер кеш-линии)

##### Типы устройства кеша
- Как кеш интерпретирует адрес ОЗУ определяет устройство кеша
1. ***Fully associative cache***
	- Строка памяти ОЗУ может попасть в любую строку кеша
	- При запросе процессором адреса идем full scan'ом по всем кеш линиям и сравниваем старшие биты этого адреса с тегами кеш-линий - фактически сравниваем номер 64Б-ого блока в ОЗУ(адрес его начала, кратный 64) с таким же номером в кеше
		- если нашелся совпадающий тег - cache hit
		- else - cache miss
	- ***Full scan - либо долго при больших размерах, либо дорого(т.к. параллельный пуск сравнения по всем строкам затратен по энергии)***
	- ***Такой вид кеша применяется на L1, т.к. он небольшого размера, зато при таком подходе коллизии и вытеснения минимальны***
1. ***Direct mapping cache***
	-  ОЗУ делится на N сегментов, каждый размер == размер кеша
	-  Каждый сегмент делится на M линий(M - кол-во кеш линий == размер кеша / размер кеш линии)
	-  В рамках линии сегмента оперируем offset'ом - от 0 до размера кеша
	![](../_resources/Pasted%20image%2020241130182640.png)
	- Когда процессор делает запрос за байтом памяти(или машинным словом):
		1. Определяется индекс кеш-строки, в которую попадет строка из ОЗУ, в которой находится данный байт(ram size/64 % m, m - число кеш-линий)
		- ***Тут видно преимущество такого устройства кеша в инженерном и алгоритмическом плане - поиск нужной строки выполняется за константное время, не делаем full scan по всем кеш-линиям кеша***	 
		- Далее путем сравнения тега запрашиваемого адреса(старшие его биты) и тега кеш линии по индексу, определяем, та ли эта строка из озу в кеше
			- если да - cache hit - по младшим 6 битам определяем оффсет нужного байта
			- если нет - cache miss - делаем запрос за кеш линий в озу
		- ***Недостаток direct mapping - строки по индексу i всех N сегментов будут мапится в одну кеш-линию с индексом i в кеше - то есть часто будет происходит вытеснение данных из кеша***
- ***N-associative cache***
![](../_resources/Pasted%20image%2020241130184858.png)
- Кеш делится на N каналов, любая строка ОЗУ может попасть в любой из каналов(fully associative) 
- Суть та же, что в direct mapping, только теперь мы определяем не конечный индекс линии в кеше, а индекс, который посмотрим в N каналах(fully associative) 
- ***Оптимальная середина между частым вытеснением(будет происходить в N раз реже) и долгим(либо дорогим) поиском фул сканом***

![](../_resources/Pasted%20image%2020241201220925.png)

![](../_resources/Pasted%20image%2020241201220957.png)

#### Алгоритмы вымещения данных из кеша
- LRU - (least recently used)вытесняется элемент, который использовался наименее недавно
- LFU - least frequently used - вытесняется элемент, который используется реже всего
- MFU - (most recently used) - вытесняется элемент, который использовался наиболее недавно

#### Когерентность кеша

 - ***Когерентность кеша*** -  согласованность содержимого локальных кешей процессоров в многопроцессорной системе между собой + согласованность их содержимого с содержимым оперативной памяти

![](../_resources/Pasted%20image%2020241130201159.png)


