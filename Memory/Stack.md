  
![](../_resources/Pasted%20image%2020241230120740.png)
    

- Куча - тоже область памяти, в ней данные расположены в порядке увеличения адресов памяти 
![Pasted image 20241230120812](../_resources/Pasted%20image%2020241230120812.png)

  

- В стеке - наоборот: данные добавляются в порядке уменьшения адресов, то есть стек растет от старшего адреса памяти к младшему
    

![Pasted image 20241230120834](../_resources/Pasted%20image%2020241230120834.png)


- Каждый элемент стека занимает одно машинное слово, то есть размер стека - это размер машинного слова    
- Для работы со стеком понадобятся указатели на его элементы:
- SP(stack pointer) - указатель вершины стека - адрес last добавленного элемента - хранится в регистре stack pointer
- Второй указатель хранится в регистре BP - адрес начала стека
    
![Pasted image 20241230120907](../_resources/Pasted%20image%2020241230120907.png)

- При команде push SP уменьшится на одно машинное слово(n байт), новый адрес будет указывать на свободную верхнюю ячейку - далее в ячейку запишется 3    
- Pop ax - взять значение, на которое указывает SP, положить значение в регистр ax, увеличить значение указателя SP на 1 машинное слово - в данном случае для примера 2 байта


![Pasted image 20241230133713](../_resources/Pasted%20image%2020241230133713.png)
- Процессор исполняет инструкции одну за другой, переходит по адресу след инструкции и тд...
	- адрес след инструкции берет из реистра ***IP***

#### Инструкции jump, call, ret
- jump {inst addr} - переход к instr addr
- call {inst addr} - формирование адреса возврата(адреса инструкции после call) + переход по inst addr - вызывается перед вызовом функции, внутри ***вызывающей функции***
- ret - извлечение адреса возврата, переход по адресу возврата - исполняется в ***вызываемой функции***
![Pasted image 20241230133730](../_resources/Pasted%20image%2020241230133730.png)

#### Пролог/эпилог функции
- Данные функции(локальные переменные) хранятся в стек-фрейме
- Формирование и удаление стек-фреймов происходит в ***прологе/эпилоге функции***
- исполнение ***call*** - вызов подфункции
	- сохранение адреса возврата
	- переход к инструкциям подфункции
- Пролог - инструкции в самом начале функции
	- ***push bp*** - сохранить значение bp стек-фрейма предыдущей функции(сохраняем старое значение bp - старый адрес) - для восстановления состояния после возврата из вызываемой функции
	- ***mov bp, sp*** -  записать в bp текущее значение sp
- Эпилог
	- ***mov sp, bp*** -  записать в sp текущее значение bp
	- ***pop bp*** -  снять старое значение bp, записать в bp старое значение bp
	- выполнить ret - извлечь адрес возврата со стека(записанный при исполнении call), перейти нему
![Pasted image 20241230133800](../_resources/Pasted%20image%2020241230133800.png)
![Pasted image 20241230134429](../_resources/Pasted%20image%2020241230134429.png)

#### Передача аргументов
![Pasted image 20241230133856](../_resources/Pasted%20image%2020241230133856.png)
- Передавать значения аргументов можно через:
	- регистры - наиболее быстрый доступ, но их число ограничено
	- стек - поход в озу, будет использовать при большом числе аругментов

![Pasted image 20241230133837](../_resources/Pasted%20image%2020241230133837.png)
- При передаче аргументов через стек:
	- их значения кладутся на вершину стека
	- далее исполняется call
	- сохранение адреса возврата, значения bp
	- адреса аргументов со значениями в стеке кладуется в регистры(а если аргументов много??)
##### удаление использованных аргументов 
![Pasted image 20241230141056](../_resources/Pasted%20image%2020241230141056.png)
![Pasted image 20241230133845](../_resources/Pasted%20image%2020241230133845.png)
![Pasted image 20241230141106](../_resources/Pasted%20image%2020241230141106.png)

- проблема - после исполнения инструкция эпилога sp будет указывать на первый аргумент функции(накидываются на стек в обратном порядке)
- способы сдвинуть sp:
	- вызываемая функция
		- при исполнении ret из стека удаляется sizeof(args) байт, sp встает на положенное место
	- вызывающая функция
		- свдиг sp на sizeof(args) байт через add sp уже после перехода по адресу возврата

#### Хранение локальных переменных в стек фрейме

![Pasted image 20241230141654](../_resources/Pasted%20image%2020241230141654.png)
- выделение памяти под локальные переменные
- запись данных по адресам, адреса формируются от bp, т.к. он статичен на протяжении жизни функции

![Pasted image 20241230141737](../_resources/Pasted%20image%2020241230141737.png)
- после завершения функции, локальные переменные больше не нужны, они перетрутся


![Pasted image 20241230141907](../_resources/Pasted%20image%2020241230141907.png)


Да, указатель базы стека (base pointer, BP), также известный как регистр `EBP` в архитектуре x86, может изменять своё значение во время вызова функций. Это связано с тем, что регистр `EBP` играет ключевую роль в организации стека и управлении локальными переменными функции.

Когда функция вызывается, она обычно сохраняет текущее значение регистра `EBP` в стеке, а затем загружает новый адрес начала фрейма стека этой функции в `EBP`. Таким образом, `EBP` становится указателем на базу текущего фрейма стека, позволяя легко обращаться к параметрам функции и её локальным переменным.

Процесс изменения значения `EBP` можно описать следующим образом:

1. **Сохранение старого значения EBP**: При входе в функцию старое значение регистра `EBP` сохраняется в стеке командой `push ebp`.
   
2. **Установка нового значения EBP**: Затем текущий указатель стека (`ESP`) копируется в `EBP` командой `mov ebp, esp`. Теперь `EBP` указывает на вершину стека, которая стала базой фрейма текущей функции.

3. **Выделение места под локальные переменные**: Если у функции есть локальные переменные, то выполняется команда вроде `sub esp, N`, чтобы освободить место под эти переменные в стеке.

После завершения работы функции происходит обратный процесс восстановления прежнего состояния стека:

1. **Освобождение локальных переменных**: Команда вроде `mov esp, ebp` освобождает память, занятую локальными переменными.

2. **Восстановление старого значения EBP**: Старое значение `EBP` восстанавливается из стека командой `pop ebp`.

3. **Возврат управления вызвавшей функции**: Выполняется команда возврата (`ret`), которая извлекает из стека адрес возврата и передает управление обратно в точку вызова функции.

Таким образом, регистр `EBP` действительно меняет своё значение во время вызовов функций, обеспечивая корректную работу со стеком и доступ к локальным переменным.